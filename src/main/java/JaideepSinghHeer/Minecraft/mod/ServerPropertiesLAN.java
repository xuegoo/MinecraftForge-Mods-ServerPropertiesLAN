package JaideepSinghHeer.Minecraft.mod;

import com.google.common.collect.Lists;
import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;
import com.google.common.io.Files;
import cpw.mods.fml.common.DummyModContainer;
import cpw.mods.fml.common.LoadController;
import cpw.mods.fml.common.Mod;
import cpw.mods.fml.common.ModMetadata;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import cpw.mods.fml.relauncher.IFMLLoadingPlugin;
import cpw.mods.fml.relauncher.ReflectionHelper;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraft.client.Minecraft;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.integrated.IntegratedServer;
import net.minecraft.server.management.ServerConfigurationManager;
import net.minecraft.server.management.UserListWhitelist;
import net.minecraftforge.common.DimensionManager;
import org.apache.logging.log4j.Level;

import java.io.*;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.Map;

/**
 * We cannot use the {@link Mod} annotation as the mod is already instantiated
 * via the {@link IFMLLoadingPlugin} interface as a CoreMod.
 *
 * We need it to be a CoreMod so that we can Edit the ByteCode
 * using the {@link net.minecraft.launchwrapper.IClassTransformer} interface.
 *
 * We Edit the ByteCode of the {@link net.minecraft.util.HttpUtil} class to return our specified Port for LAN connections.
 * @see net.minecraft.util.HttpUtil for the getSuitableLanPort() method which returns a LAN port.
 *
 */
//@Mod(modid = ServerPropertiesLAN.MODID,name=ServerPropertiesLAN.MODNAME, version = ServerPropertiesLAN.VERSION,clientSideOnly = true,acceptableRemoteVersions = "*",useMetadata = true)
@SideOnly(Side.CLIENT)
// We want our mod to load after the game is deobfuscated into SRG format by forge to make the ASM work.
@IFMLLoadingPlugin.SortingIndex(1001)
public class ServerPropertiesLAN extends DummyModContainer implements IFMLLoadingPlugin
{
    public int port=0;
    private static boolean whiteListFirstRun;
    private static boolean firstRun;
    private static IntegratedServer server;
    // ** Abandoned **
    //private long maxTickTime;

    public static final String MODID = "splan";
    public static final String MODNAME = "Server Properties for LAN";
    public static final String VERSION = "2.65-1.7.10";
    public static final String UPDATEURL = "https://raw.githubusercontent.com/jaideepheer/MinecraftForge-Mods-ServerPropertiesLAN/master/src/main/resources/update.json";

    // This Class manages all the File IO.
    private PropertyManagerClient ServerProperties = null;
    // Logger to get output in The Log.
    private static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger();

    /**
     * We don't want to do a lot of work so we extend {@link DummyModContainer}.
     * As it contains a {@link ModMetadata} object,
     * it must be initialised.
     *
     */
    public ServerPropertiesLAN()
    {
        super(new ModMetadata());
        whiteListFirstRun = false;
        System.out.println("-=-=-=-=-=-=-=ServerPropertiesLAN-Constructed=-=-=-=-=-=-=-");
        // static instance to always get the correct object.
        instance = this;
        // Mod Metadata defined in DummyModContainer received by func. getMetadata()
        ModMetadata md = getMetadata();
        md.autogenerated = false;
        md.useDependencyInformation = false;
        md.modId=MODID;
        md.version=VERSION;
        md.name=MODNAME;
        md.authorList = Lists.newArrayList("Jaideep Singh Heer");
        md.url = "https://minecraft.curseforge.com/projects/server-properties-for-lan";
        md.description = "MeoW.!\nGet the latest version at: "+md.updateUrl;
        md.credits = "by Jaideep Singh Heer";
        md.logoFile = "logo.png";
        md.screenshots = new String[]{"scr1.jpg", "Untitled.jpg", "logo2.png"};
    }

    /**
     * We cannot use {@link cpw.mods.fml.common.Mod.EventHandler} as that is a part of the {@link Mod} annotation
     * and hence requires a Class to be annotated with the {@link Mod} annotation which cannot be done for CoreMods.<See Above>
     *
     * Therefore we must register this class to the {@link EventBus} provided to it for being the {@link cpw.mods.fml.common.ModContainer}.
     *
     */
    @Override
    public boolean registerBus(EventBus bus, LoadController controller)
    {
        //System.out.println("-=-=-=-=-=-=-=EventBusRegistered=-=-=-=-=-=-=-=-");
        bus.register(this);
        return true;
    }

    /**
     * The static instance of this Class to be accessed as a Mod.
     * Forge automatically instantiates an Object for us
     * and we assign that to this object(called instance) in the constructor.
     */
    public static ServerPropertiesLAN instance;

    /**
     * This function is subscribed to the {@link EventBus} via the {@link Subscribe} annotation.
     * The type of event({@link cpw.mods.fml.common.eventhandler.Event}) to be subscribed is judged from the prototype.
     * This function gets the {@link net.minecraft.server.MinecraftServer} from the event
     * and gets the world save directory using the {@link DimensionManager}.
     *
     * It then uses the {@link PropertyManagerClient} Class to save/load data from the server.properties file
     * and sets the attributes of the {@link net.minecraft.server.MinecraftServer} via its functions.
     *
     */
    @Subscribe
    public void onServerStarting(FMLServerStartingEvent event) {
        System.out.println("========================>> Server Starting !");

        // Get the current world directory.
        String worldrootdir = DimensionManager.getCurrentSaveRootDirectory()+File.separator;

        // Define the config files.
        File local = new File(worldrootdir+"server.properties");
        File global = new File(Minecraft.getMinecraft().mcDataDir+File.separator+"config"+File.separator+"serverGlobalConfig.properties");

        // Use the appropriate config file.
        if(!global.exists())
        {
            // Probably first run. Generate global config to use.
            firstRun = true;
            ServerProperties = new PropertyManagerClient(global);
        }
        else if(local.exists()) {
            ServerProperties = new PropertyManagerClient(local);
            if(!ServerProperties.getBooleanProperty("overrideGlobalDefaults", true)) {
                ServerProperties.setPropertiesFile(global);
                LOGGER.info("Using Global Server Properties !");
            }
        }
        else{
            // Local properties file doesn't exist.
            try {
                // Copy the global config to local world and use it.
                Files.copy(global,local);
                ServerProperties = new PropertyManagerClient(local);
                ServerProperties.comment += System.getProperty("line.separator")+"overrideGlobalDefaults :"+System.getProperty("line.separator")+"\tspecify weather to use this file to override the global settings in the file \""+global.getAbsolutePath()+"\"";
                ServerProperties.getBooleanProperty("overrideGlobalDefaults", false);
                ServerProperties.saveProperties();
            } catch (IOException e) {
                LOGGER.log(Level.WARN,"Could not create local server config file. Using the global one.");
                e.printStackTrace();
                ServerProperties = new PropertyManagerClient(global);
            }
        }

        LOGGER.info("Using file : "+(ServerProperties.getBooleanProperty("overrideGlobalDefaults", true)?local.getPath():global.getPath()));
        // Get the server instance.
        server = (IntegratedServer) event.getServer();

        // Write comments to file
        ServerProperties.comment = "Minecraft Server Properties for LAN."
         + System.getProperty("line.separator")+"For default behaviour :-"
         + System.getProperty("line.separator")+"set max-view-distance=0"
         + System.getProperty("line.separator")+"set port=0"
         + System.getProperty("line.separator")+"You can also delete this(or any properties) file to get it regenerated with default values.";

        // Read data from the config file and set the server config.
        port = ServerProperties.getIntProperty("port", 0);
        // ** Abandoned **
        //maxTickTime = ServerProperties.getLongProperty("maxTickTime",-1);
        server.setOnlineMode(ServerProperties.getBooleanProperty("online-mode", true));
        server.setCanSpawnAnimals(ServerProperties.getBooleanProperty("spawn-animals", true));
        server.setCanSpawnNPCs(ServerProperties.getBooleanProperty("spawn-npcs", true));
        server.setAllowPvp(ServerProperties.getBooleanProperty("pvp", true));
        server.setAllowFlight(ServerProperties.getBooleanProperty("allow-flight", false));
        // set resource pack
        {
            Field field = ReflectionHelper.findField(MinecraftServer.class,"field_147141_M");
            field.setAccessible(true);
            try {
                field.set(server, ServerProperties.getStringProperty("resource-pack", ""));
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        server.setMOTD(ServerProperties.getStringProperty("motd", "<! "+server.getServerOwner() + "'s " + server.getWorldName()+" ON LAN !>"));
        // Set player idle timeout
        server.func_143006_e(ServerProperties.getIntProperty("player-idle-timeout", 0));
        server.setBuildLimit(ServerProperties.getIntProperty("max-build-height", 256));

        // Print data to the console
        LOGGER.info("Server Data :- ");
        LOGGER.info("online-mode = "+server.isServerInOnlineMode());
        // ** Abandoned **
        //LOGGER.info("maxTickTime = "+maxTickTime);
        LOGGER.info("spawn-animals = "+server.getCanSpawnAnimals());
        LOGGER.info("spawn-npcs = "+server.getCanSpawnNPCs());
        LOGGER.info("pvp = "+server.isPVPEnabled());
        LOGGER.info("allow-flight = "+server.isFlightAllowed());
        // get max player idle minutes
        LOGGER.info("player-idle-timeout = "+server.func_143007_ar());
        LOGGER.info("max-build-height = "+server.getBuildLimit());
        LOGGER.info("resource-pack = "+server.getTexturePack());
        LOGGER.info("motd = "+server.getMOTD());

        // Get the PlayerList Settings Object for whitelist features.
        ServerConfigurationManager customPlayerList = server.getConfigurationManager();

        // REFLECTION !!
        // NOTE : We need to make sure it works after obfuscation and so we use the ReflectionHelper class
        // which basically lets us specify many possible names for the field ...!
        // This block hacks into game to set MaxPlayers, MaxViewDistance and whitelist settings.
        try {
            // Set MaxPlayers
            Field field = ReflectionHelper.findField(ServerConfigurationManager.class,"maxPlayers","field_72405_c");
            field.setAccessible(true);
            field.set(customPlayerList, ServerProperties.getIntProperty("max-players", 10));
            LOGGER.info("Max Players = "+customPlayerList.getMaxPlayers());

            // Set MaxViewDistance
            Field dist = ReflectionHelper.findField(ServerConfigurationManager.class,"viewDistance","field_72402_d");
            dist.setAccessible(true);
            int d = ServerProperties.getIntProperty("max-view-distance", 0);
            if(d>0)
            {
                dist.set(customPlayerList, d);
                LOGGER.info("Max view distance = "+d);
            }
            else LOGGER.info("max-view-distance is set <= 0. Using default view distance algorithm.");

            // Set the server whitelist.
            if (ServerProperties.getBooleanProperty("white-list", false))
            {
                LOGGER.warn("=====>>WARNING whitelisting enabled...! Make sure at least one user entry is in the whitelist.json file !");
                File whitelistjson = new File(worldrootdir+"whitelist.json");
                UserListWhitelist whitelist = new UserListWhitelist(whitelistjson);
                if(!whitelistjson.exists()) {
                    whitelistjson.createNewFile();
                    // writeChanges()
                    whitelist.func_152678_f();
                    whiteListFirstRun = true;
                    // Set WhiteList
                    field = ReflectionHelper.findField(ServerConfigurationManager.class,"whiteListedPlayers","field_72411_j");
                    field.setAccessible(true);
                    field.set(customPlayerList, whitelist);
                }
                else {
                    // Not In First Run.
                    customPlayerList.setWhiteListEnabled(true);
                }
            }
            //server.setPlayerList(customPlayerList);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        if(firstRun)
        {
            try {
                Files.copy(global,local);
                ServerProperties.setPropertiesFile(local);
                ServerProperties.comment += System.getProperty("line.separator")+"overrideGlobalDefaults :"+System.getProperty("line.separator")+"\tspecify weather to use this file to override the global settings in the file \""+global.getAbsolutePath()+"\"";
                ServerProperties.getBooleanProperty("overrideGlobalDefaults", false);
                ServerProperties.saveProperties();
            } catch (IOException e) {
                LOGGER.error("Oops..! Couldn't copy to local server config file. Please manually copy the global server config file to your world save directory.");
                e.printStackTrace();
            }
        }
    }

    /**
     * These functions are a part of the {@link IFMLLoadingPlugin} interface.
     * @see IFMLLoadingPlugin for details.
     */
    @Override
    public String[] getASMTransformerClass() {
        return new String[]{SPLANtransformerPort.class.getCanonicalName()};
    }

    @Override
    public String getModContainerClass() {
        return ServerPropertiesLAN.class.getCanonicalName();
    }

    @Override
    public String getSetupClass() {
        return null;
    }

    @Override
    public void injectData(Map<String, Object> data){
        ;
    }

    @Override
    public String getAccessTransformerClass() {
        return null;
    }

    @Override
    public Object getMod()
    {
        return instance;
    }

    public URL getUpdateUrl()
    {
        try{
        return new URL(UPDATEURL);}
        catch (Exception e){e.printStackTrace();}
        return null;
    }
}

